FULL END-TO-END ENTERPRISE LEVEL Ansible automation for:

âœ… OpenShift login (dynamic cluster/user/password)
âœ… Intelligent dependency validation
âœ… Enterprise Istio detection (SMCP + mesh + istiod)
âœ… Enterprise cert-manager validation (CSV + Pods + CRD)
âœ… Conditional installation (safe re-run)
âœ… MSTR Operator Helm install
âœ… Runtime verification
âœ… Clean audit summary

Good ğŸ‘ â€” this is exactly what an **enterprise playbook** must have.

In real environments we **never hardcode paths, namespaces, versions, chart names, timeouts, etc.**
Everything must come from a **variables file** so you can change values without touching roles.

Below is the **proper enterprise way**.

---

# ğŸ—ï¸ Updated Enterprise Structure (with Variables)

```text id="0ce9y9"
mstr-enterprise/
â”‚
â”œâ”€â”€ playbook.yml
â”‚
â”œâ”€â”€ vars/
â”‚   â””â”€â”€ mstr_vars.yml       â­ ALL CONFIGURATION HERE
â”‚
â””â”€â”€ roles/
    â”œâ”€â”€ ocp_login/
    â”œâ”€â”€ prereq_check/
    â”œâ”€â”€ istio_validation/
    â”œâ”€â”€ cert_manager_validation/
    â”œâ”€â”€ cert_manager_install/
    â”œâ”€â”€ mstr_operator_install/
    â””â”€â”€ final_report/
```

---

# â­ 1ï¸âƒ£ GLOBAL VARIABLES FILE (MAIN PART)

## `vars/mstr_vars.yml`

This is the ONLY file you modify in future.

```yaml id="w6bwn8"
# =========================
# GLOBAL SETTINGS
# =========================

# Namespaces
cert_manager_namespace: "cert-manager"
mstr_operator_namespace: "mstr-operator"

# Helm charts
cert_manager_chart: "/tmp/cert-manager-v1.18.2.tgz"
cert_manager_values_file: "/tmp/values.yml"

mstr_operator_chart: "/tmp/mstr-operator.tgz"
mstr_operator_values_file: "value-openshift.yml"

# Installation behavior
helm_install_timeout: 600
pod_wait_retries: 20
pod_wait_delay: 15

# Detection patterns
mesh_csv_pattern: "mesh"
istiod_pattern: "istiod"
cert_crd_pattern: "cert-manager.io"
```

---

# ğŸš€ 2ï¸âƒ£ MAIN PLAYBOOK (LOAD VARIABLES)

## `playbook.yml`

```yaml id="3ycjg6"
- name: Enterprise MSTR Operator Deployment
  hosts: localhost
  gather_facts: no

  vars_files:
    - vars/mstr_vars.yml

  vars_prompt:
    - name: ocp_cluster
      prompt: "Enter OCP API URL"
      private: no

    - name: ocp_user
      prompt: "Enter OCP Username"
      private: no

    - name: ocp_pass
      prompt: "Enter OCP Password"
      private: yes

  roles:
    - ocp_login
    - prereq_check
    - istio_validation
    - cert_manager_validation
    - cert_manager_install
    - mstr_operator_install
    - final_report
```

---

# ğŸŒ 3ï¸âƒ£ Example â€” Istio Validation (Using Variables)

## `roles/istio_validation/tasks/main.yml`

```yaml id="525s3q"
- name: Detect Service Mesh operator
  shell: >
    oc get csv -A --no-headers |
    grep {{ mesh_csv_pattern }} | head -1 || true
  register: mesh_csv
  changed_when: false

- name: Parse mesh info
  set_fact:
    mesh_namespace: "{{ mesh_csv.stdout.split()[0] if mesh_csv.stdout else 'NOT_INSTALLED' }}"
    mesh_version: "{{ mesh_csv.stdout.split()[1] if mesh_csv.stdout else 'N/A' }}"

- name: Check SMCP
  shell: oc get smcp -A --no-headers || true
  register: smcp_result
  changed_when: false

- name: Check istiod pods
  shell: >
    oc get pods -A --no-headers |
    grep {{ istiod_pattern }} || true
  register: istiod_pods
  changed_when: false
```

---

# ğŸ” 4ï¸âƒ£ Cert Manager Install (Variable Driven)

## `roles/cert_manager_install/tasks/main.yml`

```yaml id="tqehy0"
- name: Install cert-manager if required
  block:

    - name: Create namespace
      command: oc create ns {{ cert_manager_namespace }}
      ignore_errors: yes

    - name: Install cert-manager helm
      shell: |
        helm upgrade --install cert-manager \
        {{ cert_manager_chart }} \
        --namespace {{ cert_manager_namespace }} \
        --values {{ cert_manager_values_file }}

  when: >
    (not cert_installed) or
    (not cert_pods_running) or
    (not cert_crd_installed)
```

---

# ğŸš€ 5ï¸âƒ£ MSTR Operator Install (Variable Driven)

## `roles/mstr_operator_install/tasks/main.yml`

```yaml id="a7xdm6"
- name: Create MSTR namespace
  command: oc create ns {{ mstr_operator_namespace }}
  ignore_errors: yes

- name: Install / Upgrade MSTR Operator
  shell: |
    helm upgrade --install mstr-operator \
      {{ mstr_operator_chart }} \
      -n {{ mstr_operator_namespace }} \
      -f {{ mstr_operator_values_file }}

- name: Wait for operator pods
  shell: oc get pods -n {{ mstr_operator_namespace }} --no-headers
  register: pod_status
  retries: "{{ pod_wait_retries }}"
  delay: "{{ pod_wait_delay }}"
  until: "'Running' in pod_status.stdout"
  changed_when: false
```

---

# ğŸ“Š 6ï¸âƒ£ Enterprise Result â€” Why This Is BEST PRACTICE

Now changing environment means editing ONLY:

```text id="hkvkbj"
vars/mstr_vars.yml
```

Example:

```yaml id="7d0r6w"
mstr_operator_namespace: "mstr-prod"
cert_manager_chart: "/backup/charts/cert-manager.tgz"
pod_wait_retries: 40
```

No role changes needed ğŸ”¥

---

# â­ ENTERPRISE BENEFITS

## âœ” Environment independent

DEV / QA / PROD use same roles.

---

## âœ” Git-friendly

Only vars change between environments.

---

## âœ” Safer upgrades

No accidental edits inside roles.

---

## âœ” CI/CD ready

Pipeline just switches variable file:

```bash id="cfzzha"
ansible-playbook playbook.yml \
-e @vars/prod.yml
```

---

# ğŸ”¥ REAL ARCHITECT LEVEL (VERY IMPORTANT TIP)

Large enterprises use **3 variable layers**:

```text id="j4uobh"
vars/common.yml
vars/dev.yml
vars/prod.yml
```

Load like:

```yaml
vars_files:
  - vars/common.yml
  - vars/prod.yml
```

---

# ğŸš€ Next Level (PLATFORM ENGINEER SECRET)

If you want, I will show you the **ULTRA CLEAN ENTERPRISE DESIGN**:

âœ” Role defaults + vars hierarchy
âœ” Auto environment switch
âœ” Zero hardcoded names anywhere
âœ” One playbook for all clusters globally

Just say:

> **â€œShow enterprise vars hierarchy designâ€** ğŸ˜
